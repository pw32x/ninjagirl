using System.Linq;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System;
using System.Text.RegularExpressions;

namespace tmx2c
{

    internal class SceneExporter
    {
        public SceneExporter()
        {
        }

        internal void ExportScene(string sceneName, 
                                  Dictionary<string, Scene> scenes, 
                                  Dictionary<string, Map> maps, 
                                  string scenesExportLocation,
                                  Dictionary<string, Tuple<int, int, int>> tileCounts)
        {
            string sceneSourceFilename = scenesExportLocation + sceneName + "_scene.c";
            string sceneHeaderFilename = scenesExportLocation + sceneName + "_scene.h";

            ExportHeaderFile(sceneName, sceneHeaderFilename);
            ExportSourceFile(sceneName, scenes, maps, sceneSourceFilename, tileCounts);
        }

        private void ExportHeaderFile(string sceneName, string sceneHeaderFilename)
        {
            using (System.IO.StreamWriter headerFile = new System.IO.StreamWriter(sceneHeaderFilename))
            {
                string headerBlock = sceneName.ToUpper() + "_SCENE_INCLUDE_H";

                headerFile.WriteLine("// this file was automatically generated by tmx2c.");
                headerFile.WriteLine("#ifndef " + headerBlock);
                headerFile.WriteLine("#define " + headerBlock);
                headerFile.WriteLine("");
                headerFile.WriteLine("#include <genesis.h>");
                headerFile.WriteLine("#include \"..\\..\\Scene.h\"");
       
                headerFile.WriteLine("");

                headerFile.WriteLine("extern const Scene " + sceneName + "_scene;");

                headerFile.WriteLine("");
                headerFile.WriteLine("#endif");
            }
        }

        private bool AddBackgroundTilesets(List<Tileset> backgroundTilesets, List<Tileset> foregroundTilesets)
        {
            if (backgroundTilesets.Count == 0)
                return false;
            
            if (foregroundTilesets.Count == 0)
                return true;

            Tileset firstBackgroundTileset = backgroundTilesets.First();
            int startIndex = -1;

            // find the first index where the background tilesets is found in the foregorund tilesets
            for (int loop = 0; loop < foregroundTilesets.Count; loop++)
            {
                Tileset foregroundTileset = foregroundTilesets[loop];

                if (firstBackgroundTileset.TilesetName == foregroundTileset.TilesetName)
                {
                    startIndex = loop;
                    break;
                }
            }

            if (startIndex == -1)
                return true;

            bool matches = true;

            for (int loop = 0; loop < backgroundTilesets.Count; loop++)
            {
                if (loop + startIndex >= foregroundTilesets.Count)
                {
                    matches = false;
                    break;
                }

                Tileset foregroundTileset = foregroundTilesets[loop + startIndex];
                Tileset backgroundTileset = backgroundTilesets[loop];

                if (backgroundTileset.TilesetName != foregroundTileset.TilesetName)
                {
                    matches = false;
                    break;
                }
            }

            return !matches;
        }

        private Tuple<Dictionary<string, int>, List<Tileset>, HashSet<string>, int, int> BuildVDPOffsetsAndTilesetsToExport(Map foregroundMap, 
                                                                                                                            Map backgroundMap, 
                                                                                                                            Dictionary<string, Tuple<int, int, int>> tileCounts)
        {
            Dictionary<string, int> vdpOffsets = new Dictionary<string, int>();
            List<Tileset> tilesetsToExport = new List<Tileset>();

            int foregroundTilesetVDPOffet = 0;
            int backgroundTilesetVDPOffet = 0;

            int currentOffset = 0;

            //var foregroundTilesets = foregroundMap.Tilesets.Where(t => !t.IsEditorTileset).OrderBy(t => t.TilesetName).ToList();
            var foregroundTilesets = foregroundMap.Tilesets.Where(t => !t.IsEditorTileset).ToList();

            // We will export everything about the foreground. 
            foreach (var tileset in foregroundTilesets)
            {
                //string tilesetName = tileset.TilesetName.Replace("_blocks", "_tileset");
                string tilesetName = Utils.ReplaceLastOccurrence(tileset.TilesetName, "_blocks", "_tileset");

                vdpOffsets.Add(tilesetName, currentOffset);
                tilesetsToExport.Add(tileset);

                if (tileset.IsAnimated)
                {
                    tileset.AnimationTileIndex = currentOffset;

                    currentOffset += (int)tileset.AnimationTileStride;
                }
                else
                {
                    currentOffset += tileCounts[tilesetName].Item1;
                }
            }

            if (backgroundMap != null)
            {
                // for the background it's more complicated.
                // if it shares any tilesets with the foreground in the same order, then
                // it can use the same tilesets. If it doesn't, then the tilesets have to 
                // loaded at the end. 

                //var backgroundTilesets = backgroundMap.Tilesets.Where(t => !t.IsEditorTileset).OrderBy(t => t.TilesetName).ToList();
                var backgroundTilesets = backgroundMap.Tilesets.Where(t => !t.IsEditorTileset).ToList();

                // if the background tilesets aren't found in the foreground tilesets in the 
                // same order, then add its tilesets.
                if (AddBackgroundTilesets(backgroundTilesets, foregroundTilesets))
                {
                    backgroundTilesetVDPOffet = currentOffset;

                    foreach (var tileset in backgroundTilesets)
                    {
                        string tilesetName = Utils.ReplaceLastOccurrence(tileset.TilesetName, "_blocks", "_tileset");

                        if (!vdpOffsets.ContainsKey(tilesetName))
                            vdpOffsets.Add(tilesetName, currentOffset);

                        tilesetsToExport.Add(tileset);

                        currentOffset += tileCounts[tilesetName].Item1;
                    }
                }
                else
                {
                    string tilesetName = Utils.ReplaceLastOccurrence(backgroundTilesets.First().TilesetName, "_blocks", "_tileset");

                    backgroundTilesetVDPOffet = vdpOffsets[tilesetName];
                }
            }

            // We can combine animations from foreground and background.
            HashSet<string> allAnimations = new HashSet<string>();
            allAnimations.UnionWith(foregroundMap.UsedAnimations);

            if (backgroundMap != null)
                allAnimations.UnionWith(backgroundMap.UsedAnimations);

            HashSet<string> usedAnimations = new HashSet<string>();

            foreach (var usedAnimation in allAnimations)
            {
                string simpleAnimationname = usedAnimation.Replace(".gal", "");

                if (vdpOffsets.ContainsKey(simpleAnimationname))
                {
                    continue;
                } 

                if (!tileCounts.ContainsKey(simpleAnimationname))
                {
                    Console.WriteLine("tmx2c Animation " + usedAnimation + " not found for computing vdp offsets.");
                    continue;
                }

                vdpOffsets.Add(simpleAnimationname, currentOffset);

                currentOffset += tileCounts[simpleAnimationname].Item1;

                usedAnimations.Add(simpleAnimationname);
            }

            return new Tuple<Dictionary<string, int>, List<Tileset>, HashSet<string>, int, int>(vdpOffsets, tilesetsToExport, usedAnimations, foregroundTilesetVDPOffet, backgroundTilesetVDPOffet);
        }

        private void ExportSourceFile(string sceneName, 
                                      Dictionary<string, Scene> scenes, 
                                      Dictionary<string, Map> maps, 
                                      string sceneSourceFilename,
                                      Dictionary<string, Tuple<int, int, int>> tileCounts)
        {
            var scene = scenes[sceneName];
            var foregroundMap = maps[scene.ForegroundMapName];
            var backgroundMap = string.IsNullOrEmpty(scene.BackgroundMapName) ? null : maps[scene.BackgroundMapName];

            var tuple = BuildVDPOffsetsAndTilesetsToExport(foregroundMap, backgroundMap, tileCounts);

            Dictionary<string, int> vdpOffsets = tuple.Item1;
            List<Tileset> tilesetsToExport = tuple.Item2;
            HashSet<string> usedAnimations = tuple.Item3;
            int foregroundTilesetVDPOffet = tuple.Item4;
            int backgroundTilesetVDPOffet = tuple.Item5;



            string loadResourcesFunctionName = "Setup" + sceneName;

            StringBuilder content = new StringBuilder();

            ExportHeader(content, sceneName, scene, usedAnimations, foregroundMap.GameObjects);

            var mapSpawner = foregroundMap.MapSpawner;

            if (foregroundMap.GameObjects.Count > 0 && mapSpawner == null)
            {
                content.Append("#include \"..\\..\\objects\\mapspawner_everything.h\"\n");
            }

            content.Append("\n");

            // if the spawner is for vertical maps, sort by Y. Else, sort by X.
            if (mapSpawner != null && mapSpawner.TemplateFilename.IndexOf("vertical", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                foregroundMap.GameObjects.Sort((s1, s2) => s1.Y.CompareTo(s2.Y));
            }
            else
            {
                foregroundMap.GameObjects.Sort((s1, s2) => s1.X.CompareTo(s2.X));
            }


            int objectId = 1;


            StringBuilder spawnListContent = new StringBuilder();
            StringBuilder runtimeAnimationContent = new StringBuilder();


            // only after exporting the spawn list can we know what their exported object ids are.
            var playerObject = ExportSpawnList(spawnListContent,
                                               runtimeAnimationContent,
                                               foregroundMap,
                                               sceneName,
                                               vdpOffsets,
                                               tileCounts,
                                               ref objectId);

            content.Append(runtimeAnimationContent.ToString());

            ExportSpawnData(content, foregroundMap, sceneName, playerObject);



            content.Append(spawnListContent.ToString());

            ExportLoadFunction(content, 
                               sceneName,
                               loadResourcesFunctionName, 
                               foregroundMap, 
                               backgroundMap, 
                               foregroundTilesetVDPOffet, 
                               backgroundTilesetVDPOffet, 
                               scene.ForegroundMapSpec,
                               scene.BackgroundMapSpec,
                               scene.BackgroundColorIndex,
                               scene,
                               tilesetsToExport, 
                               usedAnimations,
                               playerObject,
                               vdpOffsets,
                               ref objectId);

            ExportSceneStrings(content, sceneName);

            ExportSceneStruct(content, sceneName, loadResourcesFunctionName, foregroundMap, backgroundMap);


            using (System.IO.StreamWriter sourceFile = new System.IO.StreamWriter(sceneSourceFilename))
            {
                sourceFile.Write(content.ToString());
            }
        }

        private void ExportSceneStrings(StringBuilder content,
                                        string sceneName)
        {
            if (mStringManager.Strings.Count == 0)
                return;

            content.Append("const char* " + sceneName + "_strings[" + mStringManager.Strings.Count + "] = \n");
            content.Append("{\n");

            foreach (string stringToExport in mStringManager.Strings)
            {
                content.Append("    \"" + stringToExport + "\",\n");
            }

            content.Append("};\n");
            content.Append("\n");
        }

        private void ExportSceneStruct(StringBuilder content, 
                                       string sceneName, 
                                       string loadResourcesFunctionName,
                                       Map foregroundMap,
                                       Map backgroundMap)
        {
            content.Append("const Scene " + sceneName + "_scene = \n");
            content.Append("{\n");
            content.Append("    " + loadResourcesFunctionName + ", // load scene name\n");

            content.Append("    &" + foregroundMap.MapName + "_blockmap, // foreground map\n");

            if (backgroundMap != null)
                content.Append("    &" + backgroundMap.MapName + "_blockmap, // background map\n");
            else
                content.Append("    NULL, // foreground map\n");

            if (mStringManager.Strings.Count > 0)
                content.Append("    " + sceneName + "_strings, // strings used by objects in the scene\n");
            else
                content.Append("    NULL, // no strings used in this scene\n");

            content.Append("};\n");
            content.Append("\n");
        }

        private int FindPlanSize(int size)
        {
            if (size <= 32)
                return 32;
            if (size <= 64)
                return 64;

            return 128;
        }

        private void ExportLoadFunction(StringBuilder content, 
                                        string sceneName,
                                        string loadResourcesFunctionName, 
                                        Map foregroundMap, 
                                        Map backgroundMap, 
                                        int foregroundTilesetVDPOffet,
                                        int backgroundTilesetVDPOffet,
                                        MapSpec foregroundMapSpec,
                                        MapSpec backgroundMapSpec,
                                        int backgroundColorIndex,
                                        Scene scene,
                                        List<Tileset> tilesetsToExport,
                                        HashSet<string> usedAnimations,
                                        Map.GameObject playerObject,
                                        Dictionary<string, int> vdpOffsets,
                                        ref int objectId)
        {
            string unused = (playerObject != null) ? "" : "UNUSED ";

            content.Append("void " + loadResourcesFunctionName + "(" + unused + "u16 doorIndex)\n");
            content.Append("{\n");

            content.Append("    FadeManager_SetPalette(PAL0, " + scene.Palette0 + ".data);\n");
            content.Append("    FadeManager_SetPalette(PAL1, " + scene.Palette1 + ".data);\n");
            content.Append("    FadeManager_SetPalette(PAL2, " + scene.Palette2 + ".data);\n");
            content.Append("    FadeManager_SetPalette(PAL3, " + scene.Palette3 + ".data);\n");

            content.Append("    FadeManager_SetAllBlack();\n");
            content.Append("\n");

            content.Append("    VDP_setBackgroundColor(" + backgroundColorIndex  + ");\n");
            content.Append("\n");


            int verticalScrollBits = 0; // plane scrolling by default
            int horizontalScrollBits = 0;

            if (scene.VerticalScroll == Scene.VerticalScrollType.Tile)
            {
                verticalScrollBits = 1 << 2; // b100
            }

            switch (scene.HorizontalScroll)
            {
                case Scene.HorizontalScrollType.Line: horizontalScrollBits = 3;  break;
                case Scene.HorizontalScrollType.Tile: horizontalScrollBits = 2; break;
            }

            int scrollRegValue = verticalScrollBits | horizontalScrollBits;

            content.Append("    VDP_setReg(0x0b, 0x" + scrollRegValue.ToString("X2") + ");");
            content.Append(" // Vertical Scroll: " + scene.VerticalScroll.ToString() + ", Horizontal Scroll: " + scene.HorizontalScroll.ToString());
            content.Append("\n");

            /*
            int planWidth = FindPlanSize(foregroundMap.MapWidth);
            int planHeight = FindPlanSize(foregroundMap.MapHeight);

            if (planWidth * planHeight > 64 * 64)
            {
                throw new Exception("Foreground Map busts plan size");
            }

            if (backgroundMap != null)
            {
                int backgroundPlanWidth = FindPlanSize(backgroundMap.MapWidth);
                int backgroundPlanHeight = FindPlanSize(backgroundMap.MapHeight);

                if (backgroundPlanWidth > planWidth && backgroundPlanHeight > planHeight)
                {
                    throw new Exception("Background Map doesn't fit in plane");
                }


                if (backgroundPlanWidth > planWidth)
                {
                    planWidth = backgroundPlanWidth;
                }

                if (backgroundPlanHeight > planHeight)
                {
                    planHeight = backgroundPlanHeight;
                }
            }

            content.Append("    VDP_setPlanSize(" + planWidth + "," + planHeight + ");\n");

            //  Load the tilemap
            content.Append("    VDP_fillTileMapRect(APLAN, 0, 0, 0, " + planWidth + ", " + planHeight + ");\n");
            content.Append("    VDP_fillTileMapRect(BPLAN, 0, 0, 0, " + planWidth + ", " + planHeight + ");\n");
            */


            content.Append("    u16 stubTileIndex;\n");
            content.Append("\n");

            content.Append("    // Load tilesets\n");
            // write load tiles
            foreach (var tileset in tilesetsToExport)
            {
                if (tileset.IsAnimated)
                {
                    content.Append("    VDPTileManager_ReserveVDPArea(VDP_REGION_MAIN, &stubTileIndex, " + tileset.AnimationTileStride + ");");
                    content.Append("// for animated tile " + tileset.Name + "\n");
                }
                else
                {
                    //string tilesetName = tileset.TilesetName.Replace("_blocks", "_tileset");
                    string tilesetName = Utils.ReplaceLastOccurrence(tileset.TilesetName, "_blocks", "_tileset");

                    content.Append("    VDPTileManager_LoadTilesetDataToVDP(VDP_REGION_MAIN, &" + tilesetName + ", &stubTileIndex);\n");
                }
            }

            content.Append("\n");

            if (usedAnimations.Count > 0)
            {
                content.Append("    // Load animations\n");
            }

            // write load animations
            foreach (var usedAnimation in usedAnimations)
            {
                content.Append("    VDPTileManager_LoadGGAnimationToVDP(VDP_REGION_MAIN, &" + usedAnimation + ", &stubTileIndex);\n");
            }

            /*
            //  load the tilemap
            content.Append("\n");
            content.Append("    //  Load the tilemap\n");
            content.Append("    MyVDP_setTileMapRectBasetile(APLAN, " + 
                           foregroundMap.MapName + 
                           "_tilemap.tilemap_array, " + 
                           (foregroundTilesetVDPOffet + (foregroundMapSpec.Priority << 15)) + 
                           ", 0, 0, " 
                           + foregroundMap.MapWidth + ", " + 
                           foregroundMap.MapHeight + ");\n");

            if (backgroundMap != null)
            {
                content.Append("    MyVDP_setTileMapRectBasetile(BPLAN, " + 
                               backgroundMap.MapName + 
                               "_tilemap.tilemap_array, " + 
                               (backgroundTilesetVDPOffet + (backgroundMapSpec.Priority << 15)) + 
                               ", 0, 0, " + 
                               backgroundMap.MapWidth + ", " + 
                               backgroundMap.MapHeight + ");\n");
            }
            */


            string dmaDataName = "dmaData";
            int dataDmaCounter = 1;

            content.Append("\n");
            content.Append("    // create the objects that handle the planes\n");
            ExportPlaneObject(content, 
                              foregroundMap, 
                              sceneName, 
                              "VDP_PLAN_A", 
                              playerObject, 
                              foregroundMapSpec, 
                              ref objectId, 
                              0,
                              (foregroundTilesetVDPOffet + (foregroundMapSpec.Priority << 15) + (foregroundMapSpec.PaletteIndex << 13)), 
                              dmaDataName + dataDmaCounter.ToString(),
                              scene);

            dataDmaCounter++;

            if (backgroundMap != null)
            {
                content.Append("\n");
                ExportPlaneObject(content, 
                                  backgroundMap, 
                                  sceneName,
                                  "VDP_PLAN_B", 
                                  playerObject, 
                                  backgroundMapSpec, 
                                  ref objectId, 
                                  0,
                                  (backgroundTilesetVDPOffet + (backgroundMapSpec.Priority << 15) + (backgroundMapSpec.PaletteIndex << 13)),
                                  dmaDataName + dataDmaCounter.ToString(),
                                  scene);

                dataDmaCounter++;
            }

            content.Append("\n");

            if (playerObject != null)
            {
                ExportPlayerObject(content, playerObject, vdpOffsets, foregroundMap, ref objectId, 0, sceneName);
                ResolvePointerLinks(content, playerObject, foregroundMap, backgroundMap, foregroundMapSpec, backgroundMapSpec);
            }

            ExportAnimatedTiles(content, tilesetsToExport);

            ExportUpdateMaps(content, foregroundMap, backgroundMap);

            if (foregroundMap.ActiveLayers != null)
            {
                content.Append("\n");

                foreach (string activeLayer in foregroundMap.ActiveLayers)
                {
                    content.Append("    ObjectManager_layers[" + activeLayer + "] = TRUE;\n");
                }

                content.Append("\n");
            }

            // create ui and stuff for player
            ExportSpawner(content, sceneName, foregroundMap, foregroundMapSpec, ref objectId, 0, true);
            ExportSpawner(content, sceneName, backgroundMap, backgroundMapSpec, ref objectId, 0, false);

            string spawnListName = sceneName + "_" + foregroundMap.MapName + "_spawnList";
            string mapObjectName = foregroundMap.MapName + "object";

            if (foregroundMap.GameObjects.Count > 0)
            {
                content.Append("    createPersistentObjectsIfAvailable(" + spawnListName + ", " + mapObjectName + ", 1);\n");
                content.Append("\n");
            }


            content.Append("\n");
            content.Append("}\n");
            content.Append("\n");
        }

        private void ExportAnimatedTiles(StringBuilder content, List<Tileset> tilesetsToExport)
        {
            var animatedTileSets = tilesetsToExport.Where(t => t.IsAnimated);

            content.Append("\n");
            content.Append("    // setup animated tiles\n");
            content.Append("    TileAnimationManager_Init();\n");

            if (animatedTileSets.Count() > 0)
            {
                foreach (var animatedTileset in animatedTileSets)
                {
                    string animatedTilesetName = Utils.ReplaceLastOccurrence(animatedTileset.Name, "_blocks", "_tileset");

                    content.Append("    TileAnimationManager_CreateAnimatedTileset(" +
                                   "/*tileset*/" + animatedTilesetName + ".tiles, " +
                                   "/*dest vpd tile index*/" + animatedTileset.AnimationTileIndex + ", " +
                                   "/*anim frame time*/" + animatedTileset.AnimationTime + ", " +
                                   "/*total frames count*/" + animatedTileset.AnimationFramesCount + ", " +
                                   "/*anim frame tile stride*/" + animatedTileset.AnimationTileStride + ");\n");
                }
            }
        }

        private void ExportUpdateMaps(StringBuilder content, Map foregroundMap, Map backgroundMap)
        {
            content.Append("\n");
            content.Append("    //Update backgrounds once.\n");

            string foregroundMapObjectName = foregroundMap.MapName + "object";

            content.Append("    " + foregroundMapObjectName + "->updateFunction(" + foregroundMapObjectName + ");\n");

            if (backgroundMap != null)
            {
                string backgroundMapObjectName = backgroundMap.MapName + "object";
                content.Append("    " + backgroundMapObjectName + "->updateFunction(" + backgroundMapObjectName + ");\n");
            }
        }

        private void ExportSpawner(StringBuilder content, string sceneName, Map map, MapSpec mapSpec, ref int objectId, int layerIndex, bool isForeground)
        {
            if (map == null)
                return;

            if (map.GameObjects.Count == 0)
                return;

            content.Append("\n");

            string mapObjectName = map.MapName + "object";
            string spawnListName = sceneName + "_" + map.MapName + "_spawnList";

            var mapSpawner = map.MapSpawner;

            content.Append("    ");

            //if (isForeground)
            //{
            //    content.Append("    ObjectManager_SetForegroundSpawner(");
            //}
            //else
            //{
            //    content.Append("    ObjectManager_SetBackgroundSpawner(");
            //}

            if (mapSpawner != null)
            {
                content.Append(mapSpawner.GameObjectTemplate.ObjectType + "Create(" +
                               objectId++ + ", " +
                               layerIndex + ", " + 
                               mapObjectName + ", " +
                               spawnListName + ", " +
                               map.SpawnListCount + ", " +
                               mapSpec.Priority + ");\n");
            }
            else
            {
                content.Append("mapspawner_everythingCreate(" +
                               objectId++ + ", " +
                               layerIndex + ", " +
                               mapObjectName + ", " +
                               spawnListName + ", " +
                               map.SpawnListCount + ", " +
                               mapSpec.Priority + ");\n");
            }

            //content.Append(");\n");
        }

        private void ResolvePointerLinks(StringBuilder content,
                                         Map.GameObject playerObject, 
                                         Map foregroundMap, 
                                         Map backgroundMap,
                                         MapSpec foregroundMapSpec,
                                         MapSpec backgroundMapSpec)
        {
            content.Append("\n");
            content.Append("    //Resolve links between maps and the player.\n");

            string foregroundMapObjectName = foregroundMap.MapName + "object";

            if (playerObject != null) 
            {
                FollowCheck(foregroundMapSpec); 

                content.Append("    " + foregroundMapObjectName + "->parent = " + foregroundMapSpec.Follow + ";\n");

                if (backgroundMap != null)
                {
                    FollowCheck(backgroundMapSpec);
                    string backgroundMapObjectName = backgroundMap.MapName + "object";
                    content.Append("    " + backgroundMapObjectName + "->parent = " + backgroundMapSpec.Follow + ";\n");
                }

                content.Append("\n    ObjectManager_SetPlayer(playerObject);\n");
            }
        }

        private void FollowCheck(MapSpec mapSpec)
        {
            if (string.IsNullOrEmpty(mapSpec.Follow))
            {
                mapSpec.Follow = "playerObject";
                //Console.WriteLine("No follow object specified. Using playerObject by default.");
            }
        }

        private void ExportPlayerObject(StringBuilder content, 
                                        Map.GameObject playerObject, 
                                        Dictionary<string, int> vdpOffsets, 
                                        Map map, 
                                        ref int objectId,
                                        int layerIndex,
                                        string sceneName)
        {
            content.Append("    // Spawn the player.\n");

            var gameObjectTemplate = playerObject.GameObjectTemplate;

            var animationName = playerObject.UsedAssets.First().Replace(".gal", "");

            int vdpOffset = 0;

            if (!vdpOffsets.TryGetValue(animationName, out vdpOffset))
            {
                Console.WriteLine("No animation found for " + animationName);
                return;
            }



            string mapObjectName = map.MapName + "object";

            string enterSequencePropertyString = "NULL";
            GameObjectProperty enterSequenceProperty;
            if (playerObject.Properties.TryGetValue("enterSequence", out enterSequenceProperty))
                enterSequencePropertyString = enterSequenceProperty.Value;



            string spawnListName = sceneName + "_" + map.MapName + "_spawnList";

            content.Append("    Sequence playerInitSequence = NULL;\n");
            content.Append("\n");

            content.Append("	SpawnStruct spawnStruct;\n");
            content.Append("	spawnStruct.objectId = " + objectId + ";\n");
            content.Append("	spawnStruct.layerIndex = " + layerIndex + ";\n");
            content.Append("	spawnStruct.left = " + playerObject.X + ";\n");
            content.Append("	spawnStruct.top = " + (playerObject.Y - playerObject.GameObjectTemplate.Height) + ";\n");
            content.Append("	spawnStruct.runtimeAnimationData = " + playerObject.runtimeAnimationDataAddress + ";\n");
            content.Append("	spawnStruct.runtimeAnimationDataSize = " + playerObject.runtimeAnimationDataSize + ";\n");
            content.Append("\n");

            content.Append("    if (doorIndex != NO_SCENE_DOOR)\n");
            content.Append("        playerInitSequence = retrieveDoorPosition(&spawnStruct.left, &spawnStruct.top, " + spawnListName + ", doorIndex);\n");
            content.Append("\n");


            if (enterSequencePropertyString != "NULL")
            {
                content.Append("    if (playerInitSequence == NULL)\n");
                content.Append("        playerInitSequence = (doorIndex == NO_SCENE_DOOR) ? " + enterSequencePropertyString + " : NULL;\n");
            }

            content.Append("\n");



            if (!string.IsNullOrEmpty(gameObjectTemplate.ObjectType))
                content.Append("    ObjectStruct* playerObject = " + 
                               gameObjectTemplate.ObjectType + "Create(&spawnStruct,\n" +
                               "											  " + mapObjectName + ", \n" +
                               "											  " + "playerInitSequence);\n"); 
            else
                content.Append("    // " + playerObject.TemplateFilename + " missing animations for player. Can't create it.\n");
            content.Append("\n");

            objectId++;
        }

        private void ExportPlaneObject(StringBuilder content,
                                       Map map,
                                       string sceneName,
                                       string planString,
                                       Map.GameObject playerObject,
                                       MapSpec mapSpec,
                                       ref int objectId,
                                       int layerIndex,
                                       int tileAttribute,
                                       string dmaDataName,
                                       Scene scene)
        {
            // create objects for map 
            content.Append("    ");

            string mapObjectName = map.MapName + "object";

            string functionName = "ObjectStruct* " + mapObjectName + " = ";
            functionName += mapSpec.GameObjectName + "Create";
            functionName += "(";

            content.Append(functionName);

            int stringIndentLength = functionName.Length;

            string indentString = "";
            indentString = indentString.PadLeft(stringIndentLength + 4);

            content.Append(objectId + ", // object id \n");
            content.Append(indentString); content.Append(layerIndex + ", // layerIndex\n");
            content.Append(indentString); content.Append("0, // x position\n");
            content.Append(indentString); content.Append("0, // y position\n");
            content.Append(indentString); content.Append(planString + ", // which background plane it uses\n");

            content.Append(indentString); content.Append("&" + map.MapName + "_blockmap, \n");

            if (!string.IsNullOrEmpty(mapSpec.GameObjectParameters))
            {

                content.Append(indentString); content.Append("// GAME OBJECT PARAMETERS START\n"); 
                // if there's only a number, the pass it as a parameter.
                // if there's separated properties, then pass each as a parameter.
                int result = 0;
                if (int.TryParse(mapSpec.GameObjectParameters, out result))
                {
                    content.Append(indentString); content.Append(mapSpec.GameObjectParameters + ", // params \n");
                }
                else
                {
                    mapSpec.GameObjectParameters = Regex.Replace(mapSpec.GameObjectParameters, @"\s+", "");

                    string[] parameters = mapSpec.GameObjectParameters.Split(',');

                    foreach (string parameter in parameters)
                    {
                        string[] parts = parameter.Split('=');

                        if (parts.Length == 1)
                        {
                            content.Append(indentString); content.Append(parts[0] + ", \n");
                        }
                        else if (parts.Length == 2)
                        {
                            content.Append(indentString); content.Append(parts[1] + ", // " + parts[0] + "\n");
                        }
                    }
                }
                content.Append(indentString); content.Append("// GAME OBJECT PARAMETERS END\n");
            }

            content.Append(indentString); content.Append(tileAttribute + ", // tileAttr\n");

            content.Append(indentString); content.Append(dmaDataName + ", // which DMA array to use \n");

            content.Append(indentString);

            switch (scene.HorizontalScroll)
            {
                case Scene.HorizontalScrollType.Line:  content.Append("HORIZONTALSCROLLTYPE_LINE,\n"); break;
                case Scene.HorizontalScrollType.Plane: content.Append("HORIZONTALSCROLLTYPE_PLANE,\n"); break;
                case Scene.HorizontalScrollType.Tile: content.Append("HORIZONTALSCROLLTYPE_TILE,\n"); break;
            }

            content.Append(indentString);
            switch (scene.VerticalScroll)
            {
                case Scene.VerticalScrollType.Plane: content.Append("VERTICALSCROLLTYPE_PLANE"); break;
                case Scene.VerticalScrollType.Tile: content.Append("VERTICTALSCROLLTYPE_TILE"); break;
            }


            content.Append(");\n");

            objectId++;
        }

        private void ExportHeader(StringBuilder content, 
                                  string sceneName, 
                                  Scene scene, 
                                  HashSet<string> usedAnimations, 
                                  List<Map.GameObject> GameObjects)
        {
            content.Append("// this file was automatically generated by tmx2c.\n");

            content.Append("#include \"" + sceneName + "_scene.h\"\n");
            content.Append("#include \"..\\..\\RuntimeAnimationData.h\"\n");
            content.Append("#include \"..\\..\\VDP_Extra.h\"\n");
            content.Append("#include \"..\\..\\math\\MathUtils.h\"\n");
            content.Append("#include \"..\\..\\Config.h\"\n");
            content.Append("#include \"..\\audio.h\"\n");

            content.Append("#include \"..\\..\\managers\\VDPTileManager.h\"\n");

            content.Append("#include \"..\\..\\..\\gamedata\\tilesets\\tilesets.h\"\n");
            content.Append("#include \"..\\..\\..\\gamedata\\bitmaps\\bitmaps.h\"\n");

            content.Append("#include \"..\\..\\managers\\SceneManager.h\"\n");
            content.Append("#include \"..\\..\\managers\\FadeManager.h\"\n");
            content.Append("#include \"..\\..\\managers\\TileAnimationManager.h\"\n");
            content.Append("#include \"..\\..\\managers\\ObjectManager.h\"\n");
            //content.Append("#include \"..\\..\\exported\\ExportedGenResSprites.h\"\n");
            content.Append("#include \"..\\..\\objects\\planeHelperFunctions.h\"\n");
            content.Append("#include \"..\\..\\objects\\mapSpawnerHelpers.h\"\n");
            content.Append("#include \"..\\maps\\" + scene.ForegroundMapName + ".h\"\n");

            if (!string.IsNullOrEmpty(scene.BackgroundMapName))
                content.Append("#include \"..\\maps\\" + scene.BackgroundMapName +".h\"\n");

            foreach (var usedAnimation in usedAnimations)
            {
                content.Append("#include \"..\\..\\exported\\gganimations\\" + usedAnimation + ".h\"\n");
            }

            HashSet<string> uniqueObjectNames = new HashSet<string>();

            foreach (var gameObject in GameObjects)
            {
                var gameObjectTemplate = gameObject.GameObjectTemplate;

                uniqueObjectNames.Add(gameObjectTemplate.ObjectType);

                if (!String.IsNullOrEmpty(gameObject.ObjectTypeToSpawn))
                    uniqueObjectNames.Add(gameObject.ObjectTypeToSpawn);
            }

            // export the game objects used by planes.
            uniqueObjectNames.Add(scene.ForegroundMapSpec.GameObjectName);

            if (!string.IsNullOrEmpty(scene.BackgroundMapName))
            {
                uniqueObjectNames.Add(scene.BackgroundMapSpec.GameObjectName);
            }

            foreach (var objectName in uniqueObjectNames)
            {
                content.Append("#include \"..\\..\\objects\\" + objectName + ".h\"\n");
            }


        }

        private Action<StringBuilder, string> printObjectTypeInComments = (StringBuilder stringBuilder, string name) => stringBuilder.Append("/*" + name + ": */ ");
        private Action<StringBuilder, string> printPropertyNameInComments = (StringBuilder stringBuilder, string name) => stringBuilder.Append("/*" + name + " = */");

        private void ExportRuntimeAnimationData(StringBuilder content, 
                                                Map.GameObject gameObject, 
                                                Dictionary<string, int> vdpOffsets,
                                                Dictionary<string, string> runtimeAnimationStructContentCache)
        {
            gameObject.runtimeAnimationDataSize = 0;
            gameObject.runtimeAnimationDataAddress = "NULL";

            if (gameObject.GameObjectTemplate == null)
                return;

            if (gameObject.UsedAssets == null)
                return;

            string animationResourceName = gameObject.GameObjectTemplate.ObjectType + "_" + gameObject.ObjectId + "_animationResources";

            int vdpOffset = -1;

            StringBuilder structContent = new StringBuilder();

            if (gameObject.UsedAssets != null)
            {
                foreach (var animationName in gameObject.UsedAssets)
                {
                    string simpleAnimationName = animationName.Replace(".gal", "");

                    vdpOffsets.TryGetValue(simpleAnimationName, out vdpOffset);

                    structContent.Append("    { " + vdpOffset + ", &" + simpleAnimationName + " }, \n");
                }
            }

            string resultAnimationResourceName = "";
            string structContentString = structContent.ToString();

            if (runtimeAnimationStructContentCache.TryGetValue(structContentString, out resultAnimationResourceName))
            {
                animationResourceName = resultAnimationResourceName;
            }
            else
            {
                runtimeAnimationStructContentCache.Add(structContentString, animationResourceName);

                content.Append("static const RuntimeAnimationData const " + animationResourceName + "[] = \n");
                content.Append("{\n");
                content.Append(structContentString);
                content.Append("};\n");
                content.Append("\n");
            }

            gameObject.runtimeAnimationDataSize = gameObject.UsedAssets.Count();
            gameObject.runtimeAnimationDataAddress = animationResourceName;
        }

        private void ExportAllRuntimeAnimationData(StringBuilder content,
                                                   Map map,
                                                   Dictionary<string, int> vdpOffsets)
        {
            List<Map.GameObject> gameObjects = map.GameObjects;

            Dictionary<string, string> runtimeAnimationStructContentCache = new Dictionary<string, string>();

            foreach (var gameObject in gameObjects)
            {
                ExportRuntimeAnimationData(content, gameObject, vdpOffsets, runtimeAnimationStructContentCache);
            }
        }

        private void ExportInt(StringBuilder content, GameObjectProperty gameObjectDefaultProperty, Dictionary<string, GameObjectProperty> gameObjectProperties)
        {
            int propertyValue = 0;

            if (!string.IsNullOrWhiteSpace(gameObjectDefaultProperty.Value))
                propertyValue = int.Parse(gameObjectDefaultProperty.Value);

            GameObjectProperty objectProperty;

            if (gameObjectProperties.TryGetValue(gameObjectDefaultProperty.Name, out objectProperty))
            {
                propertyValue = int.Parse(objectProperty.Value);
            }

            printPropertyNameInComments(content, gameObjectDefaultProperty.Name);

            content.Append(propertyValue + ", ");
        }

        class StringManager
        {
            public int AddString(string exportString)
            {
                Strings.Add(exportString);

                return Strings.Count - 1;
            }

            public List<string> Strings = new List<string>();
        }

        StringManager mStringManager = new SceneExporter.StringManager();

        private void ExportString(StringBuilder content, GameObjectProperty gameObjectDefaultProperty, Dictionary<string, GameObjectProperty> gameObjectProperties)
        {
            string propertyValue = gameObjectDefaultProperty.Value;

            GameObjectProperty objectProperty;

            if (gameObjectProperties.TryGetValue(gameObjectDefaultProperty.Name, out objectProperty))
            {
                propertyValue = objectProperty.Value;
            }

            printPropertyNameInComments(content, gameObjectDefaultProperty.Name);

            int stringIndex = mStringManager.AddString(propertyValue);

            content.Append(stringIndex + ", ");


           //content.Append("(&" + propertyValue + "Scene >> 16), ");
           // content.Append("(&" + propertyValue + "Scene & 0x0000ffff), ");
        }

        private void ExportStringAsVariableName(StringBuilder content, GameObjectProperty gameObjectDefaultProperty, Dictionary<string, GameObjectProperty> gameObjectProperties)
        {
            string propertyValue = gameObjectDefaultProperty.Value;

            GameObjectProperty objectProperty;

            if (gameObjectProperties.TryGetValue(gameObjectDefaultProperty.Name, out objectProperty))
            {
                propertyValue = objectProperty.Value;
            }

            printPropertyNameInComments(content, gameObjectDefaultProperty.Name);

            content.Append(propertyValue + ", ");
        }

        private void ExportPointer(StringBuilder content, 
                                   GameObjectProperty gameObjectDefaultProperty, 
                                   Dictionary<string, GameObjectProperty> gameObjectProperties,
                                   StringBuilder forwardDeclareString)
        {
            string propertyValue = gameObjectDefaultProperty.Value;

            GameObjectProperty objectProperty;

            if (gameObjectProperties.TryGetValue(gameObjectDefaultProperty.Name, out objectProperty))
            {
                propertyValue = objectProperty.Value;
            }

            printPropertyNameInComments(content, gameObjectDefaultProperty.Name);

            if (string.IsNullOrEmpty(propertyValue))
                content.Append("NULL, ");
            else
            {
                forwardDeclareString.Append("#include \"" + propertyValue + "_scene.h\"\n");

                content.Append("&" + propertyValue + "_scene, ");
            }
        }

        private void ExportArray(StringBuilder content,
                                 GameObjectProperty gameObjectDefaultProperty,
                                 Dictionary<string, GameObjectProperty> gameObjectProperties,
                                 StringBuilder forwardDeclareString)
        {
            string propertyValue = gameObjectDefaultProperty.Value;

            GameObjectProperty objectProperty;

            if (gameObjectProperties.TryGetValue(gameObjectDefaultProperty.Name, out objectProperty))
            {
                propertyValue = objectProperty.Value;
            }

            printPropertyNameInComments(content, gameObjectDefaultProperty.Name);

            if (string.IsNullOrEmpty(propertyValue))
                content.Append("NULL, ");
            else
            {
                var tokens = propertyValue.Split(',');

                if (tokens.Length < 2)
                {
                    Console.WriteLine("location string for array not in correct <arrayName>,<fileName> format. Using NULL.");
                    content.Append("NULL, ");
                }
                else
                {
                    string arrayName = tokens[0];
                    string fileLocation = tokens[1];

                    forwardDeclareString.Append("#include \"..\\..\\objects\\" + fileLocation.Trim() + "\"\n");
                    content.Append(arrayName + ", ");
                }
            }
        }

        private void ExportSpawnData(StringBuilder content,
                                     Map map,
                                     string sceneName,
                                     Map.GameObject playerObject)
        {
            List<Map.GameObject> gameObjects = map.GameObjects;

            foreach (var gameObject in gameObjects)
            {
                StringBuilder spawnContent = new StringBuilder();
                StringBuilder forwardDeclareString = new StringBuilder();

                if (gameObject.GameObjectTemplate == null)
                    continue;

                if (gameObject.GameObjectTemplate.DefaultProperties.Count == 0 &&
                    gameObject.UsedAssets == null)
                    continue;

                if (gameObject == playerObject)
                    continue;

                string objectName = gameObject.GameObjectTemplate.ObjectType;

                spawnContent.Append("static " + objectName + "_spawnData const " + objectName + "_" + gameObject.ObjectId + "_spawnData = \n");
                spawnContent.Append("{\n");

                spawnContent.Append("    ");

                int numParameters = 0;

                foreach (var gameObjectDefaultProperty in gameObject.GameObjectTemplate.DefaultProperties)
                {
                    // assets are treated differently
                    if (gameObjectDefaultProperty.Name == "assets")
                        continue;

                    numParameters++;

                    switch (gameObjectDefaultProperty.Type)
                    {
                        case GameObjectProperty.GameObjectPropertyType.Int:
                            {
                                ExportInt(spawnContent, gameObjectDefaultProperty, gameObject.Properties);
                                break;
                            }
                        case GameObjectProperty.GameObjectPropertyType.String:
                            {
                                ExportString(spawnContent, gameObjectDefaultProperty, gameObject.Properties);
                                break;
                            }
                        case GameObjectProperty.GameObjectPropertyType.StringAsVariableName:
                            {
                                ExportStringAsVariableName(spawnContent, gameObjectDefaultProperty, gameObject.Properties);
                                break;
                            }
                        case GameObjectProperty.GameObjectPropertyType.Pointer:
                            {
                                ExportPointer(spawnContent, gameObjectDefaultProperty, gameObject.Properties, forwardDeclareString);
                                break;
                            }
                        case GameObjectProperty.GameObjectPropertyType.Array:
                            {
                                ExportArray(spawnContent, gameObjectDefaultProperty, gameObject.Properties, forwardDeclareString);
                                break;
                            }
                        case GameObjectProperty.GameObjectPropertyType.StaticArray:
                            {
                                ExportStaticArray(spawnContent, gameObjectDefaultProperty, gameObject.Properties, forwardDeclareString, objectName + "_" + gameObject.ObjectId);
                                break;
                            }
                    }
                }

                spawnContent.Append("\n");
                spawnContent.Append("};\n");
                spawnContent.Append("\n");

                if (numParameters > 0)
                {
                    content.Append(forwardDeclareString.ToString());

                    if (forwardDeclareString.Length > 0)
                        content.Append("\n");

                    content.Append(spawnContent.ToString());
                }
            }
        }

        private void ExportStaticArray(StringBuilder content, 
                                       GameObjectProperty gameObjectDefaultProperty, 
                                       Dictionary<string, GameObjectProperty> gameObjectProperties, 
                                       StringBuilder forwardDeclareString,
                                       string arrayPrefix)
        {
            string propertyValue = gameObjectDefaultProperty.Value;

            GameObjectProperty objectProperty;

            if (gameObjectProperties.TryGetValue(gameObjectDefaultProperty.Name, out objectProperty))
            {
                propertyValue = objectProperty.Value;
            }

            printPropertyNameInComments(content, gameObjectDefaultProperty.Name);

            if (string.IsNullOrEmpty(propertyValue))
            {
                content.Append("NULL, 0,");
            }
            else
            {
                string arrayName = gameObjectDefaultProperty.Name + arrayPrefix;

                var arrayElementCount = propertyValue.Split(' ').Count();

                var arrayElements = propertyValue.Replace(' ', ',');

                forwardDeclareString.Append("static const u16 const " + arrayName + "[] = \n");
                forwardDeclareString.AppendLine("{");
                forwardDeclareString.AppendLine(arrayElements);
                forwardDeclareString.AppendLine("};");

                content.Append(arrayName + ", /*" + gameObjectDefaultProperty.Name + "Count*/ " + arrayElementCount + ", ");
            }
        }

        private Map.GameObject ExportSpawnList(StringBuilder spawnListContent,
                                               StringBuilder runtimeAnimationContent,
                                               Map map, 
                                               string sceneName, 
                                               Dictionary<string, int> vdpOffsets,
                                               Dictionary<string, Tuple<int, int, int>> tileCounts,
                                               ref int objectId)
        {
            List<Map.GameObject> gameObjects = map.GameObjects;

            if (gameObjects.Count == 0)
            {
                return null;
            }

            string spawnListName = sceneName + "_" + map.MapName + "_spawnList";

            spawnListContent.Append("SpawnStruct const " + spawnListName + "[] = \n");
            spawnListContent.Append("{\n");

            int runtimeAnimationDataOffset = 0;

            Map.GameObject playerGameObject = null;

            int actualGameObjectCount = 0;

            spawnListContent.Append("    { NULL, (1 << 14), 0, 0, 0, 0, 0, 0, 0, 0 }, // first element\n");
            actualGameObjectCount++;

            Dictionary<string, string> runtimeAnimationStructContentCache = new Dictionary<string, string>();

            for (int loop = 0; loop < gameObjects.Count; loop++)
            {
                var gameObject = gameObjects[loop];
                var gameObjectTemplate = gameObject.GameObjectTemplate;

                bool hasSpawnData = HasSpawnData(gameObjectTemplate.DefaultProperties);
                string spawnDataName = hasSpawnData ? gameObject.GameObjectTemplate.ObjectType + "_" + objectId + "_spawnData" : "NULL";

                if (string.Equals(gameObjectTemplate.ObjectType, "player", StringComparison.OrdinalIgnoreCase))
                {
                    playerGameObject = gameObject;
                }

                gameObject.ObjectId = objectId;

                ExportRuntimeAnimationData(runtimeAnimationContent, gameObject, vdpOffsets, runtimeAnimationStructContentCache);

                //if (gameObject.UsedAssets.Contains("brightdoor"))
                //{
                //    
                //}

                if (!string.IsNullOrEmpty(gameObjectTemplate.ObjectType))
                {
                    if (!gameObject.IsMapSpawner && 
                        gameObject != playerGameObject)
                    {
                        int adjustedXEnd = 0;
                        int adjustedY;
                        int adjustedYEnd = 0;

                        // objects without an entry in game objects, like trigger areas.
                        if (gameObject.GameObjectTemplate.Id == uint.MaxValue)
                        {
                            adjustedXEnd = gameObject.X + gameObject.Width;
                            adjustedY = gameObject.Y;
                            adjustedYEnd = gameObject.Y + gameObject.Height;
                        }
                        else
                        {
                            int width = gameObject.GameObjectTemplate.Width;
                            int height = gameObject.GameObjectTemplate.Height;

                            adjustedXEnd = (gameObject.X + width - 1);
                            adjustedY =  gameObject.Y - height;
                            adjustedYEnd = adjustedY - 1;

                            if (gameObject.UsedAssets != null)
                            {
                                var animationName = gameObject.UsedAssets.First().Replace(".gal", "");

                                if (!tileCounts.ContainsKey(animationName))
                                {
                                    throw new Exception("No animation by the name of " + animationName + " exists. Are the Graphics Gale animations exported?");
                                }

                                adjustedYEnd = adjustedY + tileCounts[animationName].Item3 - 1;
                                width = tileCounts[animationName].Item2;
                            }
                        }

                        spawnListContent.Append("    { " +
                                        (spawnDataName == "NULL" ? "" : "(ObjectCreateFunctionType)") + 
                                        gameObjectTemplate.ObjectType + "Create, " +
                                        gameObject.ObjectId + ", " +
                                        gameObject.LayerIndex + ", " +
                                        gameObject.X + ", " +
                                        adjustedY + ", " +
                                        adjustedXEnd + ", " +
                                        adjustedYEnd + ", " +
                                        gameObject.runtimeAnimationDataAddress + ", " +
                                        gameObject.runtimeAnimationDataSize + ", " +
                                        (spawnDataName == "NULL" ? spawnDataName : "(const void const*)&" + spawnDataName) + 
                                        " },");

                        spawnListContent.Append("\n");

                        actualGameObjectCount++;
                    }

                    gameObject.SpawnDataName = spawnDataName;
                }
                else
                {
                    spawnListContent.Append("    {NoObjectTypeSet, 0, 0}, // " + gameObject.TemplateFilename + " missing animations\n");
                }



                objectId++;

                if (gameObject.IsObjectSpawner)
                    objectId++; // reserve an extra object id for the object it spawns

                runtimeAnimationDataOffset += gameObject.runtimeAnimationDataSize;
            }

            // add a sentinel value for the last one
            spawnListContent.Append("    { NULL, (1 << 15), 32000, 32000, 32000, 32000, 32000, 0, 0, 0 }, // last element\n"); 
            actualGameObjectCount++;

            map.SpawnListCount = actualGameObjectCount;

            spawnListContent.Append("};\n");
            spawnListContent.Append("\n");

            return playerGameObject;
        }

        private bool HasSpawnData(List<GameObjectProperty> gameObjectProperties)
        {
            foreach (var property in gameObjectProperties)
            {
                if (property.Name == "assets")
                    continue;

                return true;
            }

            return false;
        }
    }
}