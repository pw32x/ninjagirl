#include "stdafx.h"
#include "GGSMSTileAnimation.h"
#include "WriteUtils.h"
#include <fstream>
#include <algorithm>
#include <sstream>
#include "SMSCommon.h"

namespace sms
{

GGTileAnimation::GGTileAnimation(LPVOID galeFileHandle, const Options& options, AnimationProperties& animationProperties)
: m_galeFileHandle(galeFileHandle),
  m_options(options),
  m_animationProperties(animationProperties)
{
    HBITMAP bitmap = ggGetBitmap(m_galeFileHandle, 0, 0);

    if (bitmap == NULL)
    {
		printf("Error retrieving bitmap data");
		exit(-1);
    }

    if (GetObject(bitmap, sizeof(BITMAP), &m_generalBitmapInfo) == 0)
    {
        printf("BitmapInfo is NULL\n");
		exit(-1);
    }

    unsigned int numberOfFrames = ggGetFrameCount(m_galeFileHandle);
	m_frames.resize(numberOfFrames);

    m_tilesInFrame = 0;

    for (DWORD loop = 0; loop < numberOfFrames; loop++)
    {
		GGTileAnimationFrame& frame = m_frames[loop];

		frame.Init(loop, 
                   m_galeFileHandle, 
                   m_tileStore, 
                   m_options, 
                   m_animationProperties);

		m_totalFrameTime += frame.GetFrameDelayTime();

        if (!m_tilesInFrame)
        {
            m_tilesInFrame = frame.GetTilesInFrame();
        }
        else
        {
            // what to do if the next frames don't have the same number of tiles?
        }

        if (loop > 0)
        {
            int previousIndex = loop - 1;

            GGTileAnimationFrame& previousFrame = m_frames[previousIndex];

            if (previousFrame.getNextFrameIndex() == NEXT_FRAME_NOT_SET)
            {
                if (frame.startsAnimation())
                {
                    int animationStartIndex;

                    auto it = m_animationProperties.animationFrameNames.lower_bound(loop);

                    if (it != m_animationProperties.animationFrameNames.begin()) 
                    {
                        --it; // Move the iterator one step back to get the closest key
                        animationStartIndex = it->first;
                    } 
                    else 
                    {
                        animationStartIndex = 0;
                    }

                    previousFrame.setNextFrameIndex(animationStartIndex);
                }
                else
                {
                    previousFrame.setNextFrameIndex(loop);
                }
            }
        }
    }

    int lastFrameIndex = m_frames.size() - 1;

    if (m_frames[lastFrameIndex].getNextFrameIndex() == NEXT_FRAME_NOT_SET)
    {
        if (!m_frames[lastFrameIndex].startsAnimation())
        {
            auto it = m_animationProperties.animationFrameNames.lower_bound(lastFrameIndex);

            if (it != m_animationProperties.animationFrameNames.begin()) 
            {
                --it; // Move the iterator one step back to get the closest key
                m_frames[lastFrameIndex].setNextFrameIndex(it->first);
            } 
            else 
            {
                m_frames[lastFrameIndex].setNextFrameIndex(0);
            }
        }
        else
        {
            m_frames[lastFrameIndex].setNextFrameIndex(lastFrameIndex);
        }
    }
}

void GGTileAnimation::Write(const std::string& outputFolder, 
                            const std::string& outputName,
                            const std::string& bank)
{
	WriteHeaderFile(outputFolder, outputName, bank);
	WriteSourceFile(outputFolder, outputName, bank);
}

void GGTileAnimation::WriteHeaderFile(const std::string& outputFolder, 
                                      const std::string& outputName,
                                      const std::string& bank)
{
	std::string headerFilename = outputName + ".h";
	std::ofstream headerfile(outputFolder + headerFilename, std::ios::trunc);

    // header guard
    std::string headerGuard = outputName + "_ANIMATION_INCLUDE_H";
    std::transform(headerGuard.begin(), headerGuard.end(), headerGuard.begin(), ::toupper);
    headerfile << "// File generated by gg2c. https://github.com/pw32x/gg2c\n";
    headerfile << "#ifndef " << headerGuard << "\n";
    headerfile << "#define " << headerGuard << "\n";
    headerfile << "\n";

	// includes
    headerfile << "#include \"animation_types.h\"\n";
    headerfile << "#include \"resource_types.h\"\n";
    headerfile << "\n";

	// exported types

    headerfile << "RESOURCE(" << bank << ") extern const TileAnimation " << outputName << ";\n"; 

    headerfile << "\n";

    if (m_animationProperties.animationFrameNames.size() > 0)
    {
        headerfile << "// frame numbers for specific animations.\n";
        for (const auto& pair : m_animationProperties.animationFrameNames) 
	    {
		    std::transform(headerGuard.begin(), headerGuard.end(), headerGuard.begin(), ::toupper);
		    headerfile << "#define " << str_toupper(outputName) << "_" << str_toupper(pair.second) << "_FRAME_INDEX" << " " << pair.first << "\n";
        }
        headerfile << "\n";
    }

    // end header guard
    headerfile << "#endif\n\n";
    headerfile.close();
}

void GGTileAnimation::WriteFrames(const std::string& outputName, std::ofstream& sourceFile)
{
	for (size_t frameLoop = 0; frameLoop < m_frames.size(); frameLoop++)
	{
		const GGTileAnimationFrame& frame = m_frames[frameLoop];
        std::string frameName = BuildFrameName(outputName, frameLoop);

        sourceFile << "extern const TileAnimationFrame " << frameName << ";\n";
	}

	for (size_t frameLoop = 0; frameLoop < m_frames.size(); frameLoop++)
	{
		const GGTileAnimationFrame& frame = m_frames[frameLoop];

        std::string frameName = BuildFrameName(outputName, frameLoop);
        std::string nextFrameName;        

        if (frame.getNextFrameIndex() == NO_LOOP)
            nextFrameName = "NULL";
        else
            nextFrameName = "&" + BuildFrameName(outputName, frame.getNextFrameIndex());

		sourceFile << "\n";
		sourceFile << "const TileAnimationFrame " << frameName << " = \n";
		sourceFile << "{\n";

        // tile start index
        sourceFile << "    " << frame.GetTileDataIndex() << ", // tile data index\n"; 
		sourceFile << "    " << frame.GetFrameDelayTime() << ", // frame time\n"; 
        sourceFile << "    " << nextFrameName << ", // next frame\n";
		sourceFile << "};\n";
	}
}

void GGTileAnimation::WriteFrameArray(const std::string& outputName, std::ofstream& sourceFile)
{

    sourceFile << "const TileAnimationFrame* const " << outputName << "Frames[" << m_frames.size() << "] = \n";
    sourceFile << "{\n";

    for (size_t loop = 0; loop < m_frames.size(); loop++)
    {
        sourceFile << "    &" << BuildFrameName(outputName, loop) << ",\n";
    }

    sourceFile << "};\n\n";
}

void GGTileAnimation:: WriteAnimationStruct(const std::string& outputName, 
                                            std::ofstream& sourceFile,
                                            const std::string& bank)
{
    sourceFile << "u8 " << outputName << "VdpLocation;\n\n";

    // final struct
    sourceFile << "RESOURCE(" << bank << ") const TileAnimation " << outputName << " = \n";
    sourceFile << "{\n";
    sourceFile << "    TILE_ANIMATION_RESOURCE_TYPE, \n";
    sourceFile << "    (const TileAnimationFrame** const)" << outputName << "Frames,\n";

    sourceFile << "    (unsigned char* const)" << outputName << "TileData, // start of the sprite data\n";
    sourceFile << "    " << m_frames.size() << ", // number of frames\n";
    sourceFile << "    " << m_tilesInFrame << ", // the max amount of sprite tiles in a frame\n";    
    sourceFile << "    " << m_tileStore.size() << ", // the total amount of tiles in animation\n";

    sourceFile << "    &" << outputName << "VdpLocation,\n";
    sourceFile << "};\n";
}


void GGTileAnimation::WriteSourceFile(const std::string& outputFolder, 
                                      const std::string& outputName,
                                      const std::string& bank)
{
	std::ofstream sourceFile(outputFolder + outputName + ".c");

    // includes
    sourceFile << "#include \"" << outputName << ".h\"\n";
	
    sourceFile << "\n";
    sourceFile << "\n";

	// tile data
	WriteTileStore(outputName, sourceFile, m_tileStore);

	WriteFrames(outputName, sourceFile);
    WriteFrameArray(outputName, sourceFile);
    WriteAnimationStruct(outputName, sourceFile, bank);

    sourceFile.close();
}



}