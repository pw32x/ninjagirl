#include "stdafx.h"
#include "GGAnimation.h"
#include "WriteUtils.h"
#include <fstream>
#include <algorithm>
#include <sstream>

GGAnimation::GGAnimation(LPVOID galeFileHandle, const Options& options, AnimationProperties& animationProperties)
: m_galeFileHandle(galeFileHandle),
  m_tileCount(0),
  m_maxTilesPerFrame(0),
  m_options(options),
  m_numberOfFrames(ggGetFrameCount(m_galeFileHandle)),
  m_animationProperties(animationProperties),
  mHasFrameTriggerData(false)
{
    HBITMAP bitmap = ggGetBitmap(m_galeFileHandle, 0, 0);

    if (bitmap == NULL)
    {
		printf("Error retrieving bitmap data");
		exit(-1);
    }

    if (GetObject(bitmap, sizeof(BITMAP), &m_generalBitmapInfo) == 0)
    {
        printf("BitmapInfo is NULL\n");
		exit(-1);
    }

	/*
	FILE* file;
	fopen_s(&file, "output.txt", "w");
	fclose(file);
	*/

	m_frames.resize(m_numberOfFrames);

    for (DWORD loop = 0; loop < m_numberOfFrames; loop++)
    {
		GGAnimationFrame& frame = m_frames[loop];

		frame.Init(loop, m_galeFileHandle, m_rawSprites, m_spriteProperties, m_spriteArrays, m_options, m_animationProperties, m_tileCount);

		int tileCount = frame.GetTileCount();
		if (tileCount > m_maxTilesPerFrame)
		{
			m_maxTilesPerFrame = tileCount;
		}

		m_totalFrameTime += frame.GetFrameDelayTime();
    }
}

void GGAnimation::Write(const std::string& outputFolder, const std::string& outputName)
{
	WriteGGAnimationHeaderFile(outputFolder, outputName);
	WriteGGAnimationSourceFile(outputFolder, outputName);
}

void GGAnimation::WriteGGAnimationHeaderFile(const std::string& outputFolder, const std::string& outputName)
{
	std::string headerFilename = outputName + ".h";
	std::ofstream headerfile(outputFolder + headerFilename);

    // header guard
    std::string headerGuard = outputName + "_ANIMATION_INCLUDE_H";
    std::transform(headerGuard.begin(), headerGuard.end(), headerGuard.begin(), ::toupper);
    headerfile << "// File generated by gg2c. https://github.com/pw32x/gg2c\n";
    headerfile << "#ifndef " << headerGuard << "\n";
    headerfile << "#define " << headerGuard << "\n";
    headerfile << "\n";

	// includes
    headerfile << "#include \"GGAnimationTypes.h\"\n";
    headerfile << "\n";

	// exported types
    headerfile << "extern const GGAnimation " << outputName << ";\n"; 
    headerfile << "\n";

    // end header guard
    headerfile << "#endif\n\n";
    headerfile.close();
}

 

void GGAnimation::WriteSpritesData(const std::string& outputName, std::ofstream& sourceFile)
{
	for (size_t loop = 0; loop < m_spriteProperties.size(); loop++)
	{
		std::string spriteName = BuildSpriteName(outputName, loop);

		const SpriteProperties& properties = m_spriteProperties[loop];
		const RawSprite& rawSprite = m_rawSprites[properties.rawSprite];
		int tileStartIndex = rawSprite.tileStartIndex;

        sourceFile << "const GGSprite " << spriteName << " = \n";
        sourceFile << "{\n";
        sourceFile << "    " << properties.xPositionOffset - m_animationProperties.mOffsetX << ", // x position offset\n";
        sourceFile << "    " << properties.yPositionOffset - m_animationProperties.mOffsetY  << ", // y position offset\n";
		sourceFile << "    " << properties.xFlippedPositionOffset << ", // x flipped position offset\n";
        sourceFile << "    TILE_ATTR_FULL(PAL0, 0, " << properties.verticalFlip << ", " << properties.horizontalFlip << ", " << tileStartIndex << "), // tile attribute and tile offset in sprite tile data\n";
        sourceFile << "    SPRITE_SIZE(" << rawSprite.tileWidth << ", " << rawSprite.tileHeight << "), // sgdk sprite size\n";
        sourceFile << "};\n\n";
	}
}





void GGAnimation::WriteFrameSpriteArrayData(const std::string& outputName, std::ofstream& sourceFile)
{
	for (size_t loop = 0; loop < m_spriteArrays.size(); loop++)
	{
		const std::vector<int>& spriteArray = m_spriteArrays[loop];

		if (spriteArray.size() == 0)
			continue;

		sourceFile << "const GGSprite* const " << BuildSpriteArrayName(outputName, loop) << "[" << spriteArray.size() << "] = \n";
		sourceFile << "{\n";		

		for (size_t loop = 0; loop < spriteArray.size(); loop++)
		{
			sourceFile << "    &" << BuildSpriteName(outputName, spriteArray[loop]) << ",\n";
		}

		sourceFile << "};\n\n";		
	}
}





void GGAnimation::WriteFrames(const std::string& outputName, std::ofstream& sourceFile)
{
    // forward declare frame names.
    for (size_t frameLoop = 0; frameLoop < m_frames.size(); frameLoop++)
    {
        sourceFile << "extern const GGFrame " << BuildFrameName(outputName, frameLoop) << ";\n";
    }

	sourceFile << "\n\n";

	int frameTriggerDataCount = 0;
	for (size_t frameLoop = 0; frameLoop < m_frames.size(); frameLoop++)
	{
		const GGAnimationFrame& frame = m_frames[frameLoop];

		if (frame.GetFrameTriggerData().size() > 0)
		{
			if (frameTriggerDataCount == 0)
			{
				//  print start of array
				sourceFile << "s16 const " << outputName << "FrameTriggerData[] = \n";
				sourceFile << "{\n";
				sourceFile << "	0,\n";
				mHasFrameTriggerData = true;
			}

			for (const auto& frameTriggerData : frame.GetFrameTriggerData())
			{
				sourceFile << "	" << frameTriggerData << ", \n";
			}

			frameTriggerDataCount += frame.GetFrameTriggerData().size();
		}
	}

	if (frameTriggerDataCount > 0)
	{
		// print end of array
		sourceFile << "};\n";
	}

	sourceFile << "\n\n";

	int frameTriggerDataOffset = 1;

	for (size_t frameLoop = 0; frameLoop < m_frames.size(); frameLoop++)
	{
		const GGAnimationFrame& frame = m_frames[frameLoop];

		sourceFile << "\n";
		sourceFile << "const GGFrame " << BuildFrameName(outputName, frameLoop) << " = \n";
		sourceFile << "{\n";

		const std::vector<int>& spriteArray = m_spriteArrays[frame.GetSpriteArrayIndex()];

		if (spriteArray.size() > 0)
			sourceFile << "    " << BuildSpriteArrayName(outputName, frame.GetSpriteArrayIndex()) << ",\n";
		else
			sourceFile << "    NULL,\n";


		sourceFile << "    " << spriteArray.size() << ", // number of sprites\n";

		if (frame.GetFrameTriggerData().size() > 0)
		{
			sourceFile << "    " << frameTriggerDataOffset << ", // frame trigger data offset\n"; 
			frameTriggerDataOffset += frame.GetFrameTriggerData().size();
		}
		else
		{
			sourceFile << "    0, // frame trigger data offset\n"; 
		}

		sourceFile << "    " << frame.GetFrameDelayTime() << ", // frame time\n"; 

		if (frameLoop + 1 > m_frames.size() - 1)
		{
			if (m_options.mNoLoop)
			{
				sourceFile << "    NULL, // stop animation. no looping\n";
			}
			else
			{
				sourceFile << "    &" << BuildFrameName(outputName, 0) << ", // loop to next frame. \n";
			}
		}
		else
		{
			sourceFile << "    &" << BuildFrameName(outputName, frameLoop + 1) << ", // next frame\n";
		}

		sourceFile << "};\n";
		sourceFile << "\n";

	}
}

void GGAnimation::WriteFrameArray(const std::string& outputName, std::ofstream& sourceFile)
{
    sourceFile << "const GGFrame* const " << outputName << "Frames[" << m_frames.size() << "] = \n";
    sourceFile << "{\n";

    for (size_t loop = 0; loop < m_frames.size(); loop++)
    {
        sourceFile << "    &" << BuildFrameName(outputName, loop) << ",\n";
    }

    sourceFile << "};\n\n";
}


void GGAnimation:: WriteAnimationStruct(const std::string& outputName, std::ofstream& sourceFile)
{
    // final struct
    sourceFile << "\n";
    sourceFile << "\n";

    sourceFile << "const GGAnimation " << outputName << " = \n";
    sourceFile << "{\n";
    sourceFile << "    " << outputName << "Frames,\n";
    sourceFile << "    " << m_frames.size() << ", // number of frames\n";
    sourceFile << "    " << m_generalBitmapInfo.bmWidth << ", // width in pixels\n";
    sourceFile << "    " << m_generalBitmapInfo.bmHeight << ", // height in pixels\n";
    sourceFile << "    " << m_maxTilesPerFrame << ", // max tiles per frame\n";
    sourceFile << "    " << m_tileCount << ", // the total number of tiles in the animation\n";
    sourceFile << "    (u32*)" << outputName << "TileData, // start of the sprite data\n";

	if (mHasFrameTriggerData)
		sourceFile << "    " <<  outputName << "FrameTriggerData, // frame trigger data blob\n";
	else 
		sourceFile << "    NULL, // frame trigger data blob\n";

    sourceFile << "};\n";
}

void GGAnimation::WriteGGAnimationSourceFile(const std::string& outputFolder, const std::string& outputName)
{
	std::ofstream sourceFile(outputFolder + outputName + ".c");

    // includes
    sourceFile << "#include <genesis.h>\n";
    sourceFile << "#include \"" << outputName << ".h\"\n";
	sourceFile << "#include \"GGFrameTriggers.h\"\n";
	
    sourceFile << "\n";
    sourceFile << "\n";

	// tile data
	WriteTileData(outputName, sourceFile, m_rawSprites);

	// sprites
	WriteSpritesData(outputName, sourceFile);

	// frames sprite arrays
	WriteFrameSpriteArrayData(outputName, sourceFile);

	// frames
	WriteFrames(outputName, sourceFile);

	// frame array
	WriteFrameArray(outputName, sourceFile);

	// animation
	WriteAnimationStruct(outputName, sourceFile);

    sourceFile.close();
}