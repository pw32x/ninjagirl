#include "stdafx.h"
#include "GGSMSPlaneAnimation.h"
#include "BitmapUtils.h"
#include "WriteUtils.h"
#include <fstream>
#include <algorithm>
#include <sstream>
#include <iomanip>

namespace sms
{

GGPlaneAnimation::GGPlaneAnimation(LPVOID galeFileHandle, const Options& options)
: m_galeFileHandle(galeFileHandle),
  m_uniqueTileCount(0),
  m_maxUniqueTilesPerFrame(0),
  m_options(options),
  m_numberOfFrames(ggGetFrameCount(m_galeFileHandle))
{
    HBITMAP bitmap = ggGetBitmap(m_galeFileHandle, 0, 0);

    if (bitmap == NULL)
    {
		printf("Error retrieving bitmap data");
		exit(-1);
    }

    if (GetObject(bitmap, sizeof(BITMAP), &m_generalBitmapInfo) == 0)
    {
        printf("BitmapInfo is NULL\n");
		exit(-1);
    }

	m_frames.resize(m_numberOfFrames);

    for (DWORD loop = 0; loop < m_numberOfFrames; loop++)
    {
		GGPlaneAnimationFrame& frame = m_frames[loop];

		frame.Init(loop, m_galeFileHandle, m_tileStore, m_options, m_uniqueTileCount, m_maxUniqueTilesPerFrame);

		if (findSameFrame(frame) == nullptr)
		{
			m_uniqueFrameData.push_back(&frame);
		}
    }
}

GGPlaneAnimationFrame* GGPlaneAnimation::findSameFrame(const GGPlaneAnimationFrame& frame)
{
	for (auto uniqueFrameData : m_uniqueFrameData)
	{
		if (uniqueFrameData->hasSameFrameData(&frame))
		{
			return uniqueFrameData;
		}
	}

	return nullptr;
}

int GGPlaneAnimation::findSameFrameIndex(const GGPlaneAnimationFrame& frame)
{
	for (size_t loop = 0; loop < m_uniqueFrameData.size(); loop++)
	{
		if (m_uniqueFrameData[loop]->hasSameFrameData(&frame))
		{
			return loop;
		}
	}

	return -1;
}


void GGPlaneAnimation::Write(const std::string& outputFolder, const std::string& outputName, const std::string& bank)
{
	WriteGGPlaneAnimationHeaderFile(outputFolder, outputName, bank);
	WriteGGPlaneAnimationSourceFile(outputFolder, outputName, bank);
}

void GGPlaneAnimation::WriteGGPlaneAnimationHeaderFile(const std::string& outputFolder, 
													   const std::string& outputName,
													   const std::string& bank)
{
	std::string headerFilename = outputName + ".h";
	std::ofstream headerfile(outputFolder + headerFilename);

    // header guard
    std::string headerGuard = outputName + "_ANIMATION_INCLUDE_H";
    std::transform(headerGuard.begin(), headerGuard.end(), headerGuard.begin(), ::toupper);
    headerfile << "// File generated by gg2c. https://github.com/pw32x/gg2c\n";
    headerfile << "#ifndef " << headerGuard << "\n";
    headerfile << "#define " << headerGuard << "\n";
    headerfile << "\n";

	// includes
    headerfile << "#include \"animation_types.h\"\n";
	headerfile << "#include \"resource_types.h\"\n";
    headerfile << "\n";

	// exported types
    headerfile << "RESOURCE(" << bank << ") extern const PlaneAnimation " << outputName << ";\n"; 

	/*
	if (m_options.mFixedBack)
	{
		headerfile << "extern const VDPTileIndex " << outputName << "VDPTileIndex;\n";  
	}
	else
	{
		headerfile << "extern VDPTileIndex " << outputName << "VDPTileIndex;\n";  
	}

    headerfile << "\n";

	if (m_options.mFixedBack)
	{
		headerfile << "#define " << outputName << "LoadFixed() VDPTileManager_LoadGGPlaneAnimationToVDPFixed(&" << outputName << ", " << outputName << "VDPTileIndex)\n\n";
	}
	else
	{
		headerfile << "#define " << outputName << "Load(region) VDPTileManager_LoadGGPlaneAnimationToVDP(region, &" << outputName << ", &" << outputName << "VDPTileIndex)\n\n";
	}
	*/

	headerfile << "\n";
    // end header guard
    headerfile << "#endif\n\n";
    headerfile.close();
}

std::string BuildFrameDataName(const std::string outputName, int index)
{
    std::stringstream stringStream;
    stringStream << outputName << "FrameData" << index;

    return stringStream.str();
}

void GGPlaneAnimation::WriteFrameData(const std::string& outputName, std::ofstream& sourceFile)
{
	for (size_t loop = 0; loop < m_uniqueFrameData.size(); loop++)
	{
		std::string frameName = BuildFrameDataName(outputName, loop);

		const GGPlaneAnimationFrame* frame = m_uniqueFrameData[loop];
		//
        sourceFile << "const unsigned short const " << frameName << "[" << frame->tileWidth() * frame->tileHeight() << "] = // " << frame->tileWidth() << " x " << frame->tileHeight() << "\n";
        sourceFile << "{\n";

		for (int loopHeight = 0; loopHeight < frame->tileHeight(); loopHeight++)
		{
			for (int loopWidth = 0; loopWidth < frame->tileWidth(); loopWidth++)
			{
				int value = frame->frameData()[loopWidth + (loopHeight * frame->tileWidth())];

				if (m_options.mFixedBack)
				{
					value += (Options::VDP_SIZE - m_uniqueTileCount);
				}

				sourceFile << std::setw(4) << value << ", ";
			}

			sourceFile << "\n";
		}

        sourceFile << "};\n\n";
		
	}
}


std::string BuildFrameTileMapName(const std::string outputName, int index)
{
    std::stringstream stringStream;
    stringStream << outputName << "TileMap" << index;

    return stringStream.str();
}


std::string BuildFramePaletteName(const std::string outputName, int index)
{
    std::stringstream stringStream;
    stringStream << outputName << "Palette" << index;

    return stringStream.str();
}

unsigned short getClosestBrightness(BYTE channel)
{
	//if (channel >= 255) return 7;
	//if (channel >= 206) return 6;
	//if (channel >= 172) return 5;
	//if (channel >= 144) return 4;
	//if (channel >= 116) return 3;
	//if (channel >= 87) return 2;
	//if (channel >= 52) return 1;
	//return 0;

	//if (channel >= 206) return 7;
	//if (channel >= 172) return 6;
	//if (channel >= 144) return 5;
	//if (channel >= 116) return 4;
	//if (channel >= 87) return 3;
	//if (channel >= 52) return 2;
	//if (channel > 0) return 1;
	//return 0;


	if (channel >= 255) return 7;
	if (channel >= 206) return 6;
	if (channel >= 172) return 5;
	if (channel >= 144) return 4;
	if (channel >= 116) return 3;
	if (channel >= 87) return 2;
	if (channel >= 52) return 1;
	return 0;
}

void GGPlaneAnimation::WritePalettes(const std::string& outputName, std::ofstream& sourceFile)
{
	for (size_t frameLoop = 0; frameLoop < m_uniqueFrameData.size(); frameLoop++)
	{
		std::string paletteName = BuildFramePaletteName(outputName, frameLoop);

		const GGPlaneAnimationFrame* frame = m_uniqueFrameData[frameLoop];

		const PALETTEENTRY* paletteEntries = frame->getPalette();

		sourceFile << "unsigned short " << paletteName << "[16] = \n"; 
		sourceFile << "{\n";

		for (int loop = 0; loop < PALETTE_SIZE; loop++)
		{
			const PALETTEENTRY* paletteEntry = &paletteEntries[loop];

			// Which RGB to Genesis color conversion is best????

			//unsigned short red = (unsigned short)((float)paletteEntry->peRed / 256.0f * 8);
			//unsigned short green = (unsigned short)((float)paletteEntry->peGreen / 256.0f * 8);
			//unsigned short blue = (unsigned short)((float)paletteEntry->peBlue / 256.0f * 8);


			//unsigned short red = (unsigned short)((float)paletteEntry->peRed / 255.0f * 7);
			//unsigned short green = (unsigned short)((float)paletteEntry->peGreen / 255.0f * 7);
			//unsigned short blue = (unsigned short)((float)paletteEntry->peBlue / 255.0f * 7);

			unsigned short red = getClosestBrightness(paletteEntry->peRed);
			unsigned short green = getClosestBrightness(paletteEntry->peGreen);
			unsigned short blue = getClosestBrightness(paletteEntry->peBlue);
			unsigned short paletteValue = (unsigned short)((red << 1) | (green << 5) | (blue << 9));

			sourceFile << "    0x" << std::hex << paletteValue << ", \n";
		}

		sourceFile << "};\n";
	}
}

void GGPlaneAnimation::WriteTileMaps(const std::string& outputName, std::ofstream& sourceFile)
{
	for (size_t frameLoop = 0; frameLoop < m_uniqueFrameData.size(); frameLoop++)
	{
		std::string frameName = BuildFrameDataName(outputName, frameLoop);

		const GGPlaneAnimationFrame* frame = m_uniqueFrameData[frameLoop];
		auto width = frame->tileWidth();
		auto height = frame->tileHeight();
		auto frameData = frame->frameData();

		sourceFile << "const unsigned short " << BuildFrameTileMapName(outputName, frameLoop) << "[" << std::dec << width << " * " << height << "] = \n";
        sourceFile << "{\n";

		for (int loopy = 0; loopy < frame->tileHeight(); loopy++)
		{
			sourceFile << "    ";
			for (int loopx = 0; loopx < frame->tileWidth(); loopx++)
			{
				auto tileValue = frameData[loopx + (loopy * frame->tileWidth())];
				sourceFile << "0x" << std::hex << tileValue << ", ";
			}

			sourceFile << "\n";
		}

        sourceFile << std::dec << "};\n\n";
	}
}


void GGPlaneAnimation::WriteFrameNames(const std::string& outputName, std::ofstream& sourceFile)
{
    // forward declare frame names.
	for (size_t loop = 0; loop < m_frames.size(); loop++)
	{
		sourceFile << "extern const PlaneAnimationFrame " << BuildFrameName(outputName, loop) << ";\n";
	}

	sourceFile << "\n\n";
}


void GGPlaneAnimation::WriteFrames(const std::string& outputName, std::ofstream& sourceFile)
{
	for (size_t loop = 0; loop < m_frames.size(); loop++)
	{
		auto& frame = m_frames[loop];

		sourceFile << "\n";
		sourceFile << "const PlaneAnimationFrame " << BuildFrameName(outputName, frame.frameNumber()) << " = \n";
		sourceFile << "{\n";

		int uniqueFrameIndex = findSameFrameIndex(frame);
		sourceFile << "    " << BuildFrameTileMapName(outputName, uniqueFrameIndex) << ", // frame tilemap\n";
		sourceFile << "    " << frame.getFrameDelayTime() << ", // frame time\n"; 
		//sourceFile << "    " << BuildFramePaletteName(outputName, uniqueFrameIndex) << ", // frame tilemap\n";

		if (loop + 1 > m_frames.size() - 1)
		{
			if (m_options.mNoLoop)
			{
				sourceFile << "    NULL, // stop animation. no looping\n";
			}
			else
			{
				sourceFile << "    &" << BuildFrameName(outputName, 0) << ", // loop to next frame. \n";
			}
		}
		else
		{
			sourceFile << "    &" << BuildFrameName(outputName, loop + 1) << ", // next frame\n";
		}

		sourceFile << "};\n";
		sourceFile << "\n";
	}	
}

std::string BuildFrameArrayName(const std::string& outputName)
{
    std::stringstream stringStream;
    stringStream << outputName << "Frames";

    return stringStream.str();
}


void GGPlaneAnimation::WriteFrameArray(const std::string& outputName, std::ofstream& sourceFile)
{
	sourceFile << "const PlaneAnimationFrame* const " << BuildFrameArrayName(outputName) << "[" << m_frames.size() << "] =\n";
	sourceFile << "{\n";		

	for (size_t loop = 0; loop < m_frames.size(); loop++)
	{
		auto& frame = m_frames[loop];

		sourceFile << "    &" << BuildFrameName(outputName, frame.frameNumber()) << ",\n";
	}

	sourceFile << "};\n\n";		
}

void GGPlaneAnimation::WriteAnimationStruct(const std::string& outputName, 
											std::ofstream& sourceFile,
											const std::string& bank)
{
    // final struct
    sourceFile << "\n";
    sourceFile << "\n";

	int vdpPosition = Options::VDP_SIZE - m_uniqueTileCount;

	/*
	if (m_options.mFixedBack)
	{
		sourceFile << "const VDPTileIndex " << outputName << "VDPTileIndex = " << vdpPosition << ";\n";
	}
	else
	{
		sourceFile << "VDPTileIndex " << outputName << "VDPTileIndex;\n";   
	}
	*/

	sourceFile << "u16 " << outputName << "VdpLocation;\n\n";

    sourceFile << "\n";
	

    sourceFile << "RESOURCE(" << bank << ") const PlaneAnimation " << outputName << " = \n";
    sourceFile << "{\n";
	sourceFile << "    PLANE_ANIMATION_RESOURCE_TYPE, \n";
    sourceFile << "    " << outputName << "Frames,\n";
    sourceFile << "    " << m_frames.size() << ", // number of frames\n";
	sourceFile << "    " << m_frames[0].tileWidth() << ", // width of the total area of the frame in tiles\n";
	sourceFile << "    " << m_frames[0].tileHeight() << ", // height of the total area of the frame in tiles\n";
    sourceFile << "    " << m_tileStore.size() << ", // the total number of tiles in the animation\n";
    sourceFile << "    " << outputName << "TileData, // start of the tile data\n";
    //sourceFile << "    &" << outputName << "VDPTileIndex, // vdp tile index\n";
	sourceFile << "    &" << outputName << "VdpLocation,\n";
    sourceFile << "};\n";
}


void GGPlaneAnimation::WriteGGPlaneAnimationSourceFile(const std::string& outputFolder, 
													   const std::string& outputName,
													   const std::string& bank)
{
	std::ofstream sourceFile(outputFolder + outputName + ".c");

    // includes
	sourceFile << "// File generated by gg2c. https://github.com/pw32x/gg2c\n";
    sourceFile << "#include \"" << outputName << ".h\"\n";
    sourceFile << "\n";
    sourceFile << "\n";

	WriteTileStore(outputName, sourceFile, m_tileStore);

	//WriteFrameData(outputName, sourceFile);
	//WritePalettes(outputName, sourceFile);
	WriteTileMaps(outputName, sourceFile);
	WriteFrameNames(outputName, sourceFile);
	WriteFrames(outputName, sourceFile);

	WriteFrameArray(outputName, sourceFile);

	WriteAnimationStruct(outputName, sourceFile, bank);

    sourceFile.close();
}


}